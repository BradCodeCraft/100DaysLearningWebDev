Simple JSX Element
    React uses a syntax extension of JS called JSX that allows you to write HTML within JS.
        Benefits:
            Let you use the full programmatic power of JS within HTML
            Helps to keep your code readable

    Write JS codes in curly braces within JSX:
        { ____ }

    Use transpiler Babel to compile JSX code into JS

    ReactDOM.render(JSX, document.getElementById('root'))
        This places your JSX into React's own lightweight representation of the DOM

Complex JSX Element:
    Nested JSX must return a single element
        One parent element would wrap all of the other levels of nested element

Add Comments in JSX
    You use the syntax {/* ____ */}

Render HTML Elements to the DOM
    ReactDOM offers a simple method to render Rect elements to the DOM which looks like this:
        ReactDOM.render(componentToRender, targetNode)

        ReactDOM.render() must be called after the JSX element declarations

Define an HTML Class in JSX
    In JSX, you can no longer use the word "class" to define HTML classes.
        Instead, JSX uses "className"
    Naming connvention for all HTML attributes and event references in JSX become camelCase.
    
Self-Closing JSX Tags
    Any JSX element can be written with a self-closing tag, and every element must be closed.
        e.g.:
            <br />
            <hr />
            <div />
    The differnce is that in the first syntax version, there is no way to include anything in the <div />

Create a Stateless Functional Component
    There are two ways to create a React component.
        Using JS function
            Defining a component in this wway creates a stateless functional component.
                i.e., component that can receive data and render it, but does not manage or track changes to that data.
            To create a component with a function, you simply write a JS function that returns either JSX or null
            React requires your function name to begin with a capital letter
            
            Because a JSX component represents HTML, you could put several components together to create a more complex HTML page.
                It allows you to compose your UI from many separate, isolated components.
                This makes it easier to build and maintain complex user interfaces/

Create a React Component
    The other way to define a React component is with the ES6 "class" syntax.
        class ____ extends React.Component {
            constructor(props) {
                super(props);
            }
        }
            "super()" calls the constructor of the parent class, i.e. React.Component.

Create a Component with Composition
    To compose components together, you could create an "App" parent component which renders each of these three components as children.
    To render a component as a child in a React component, you include the component name written as a custom HTML tag in the JSX.
        e.g.:
            return (
                <App>
                    <Navbar />
                    <Dashboard />
                    <Footer />
                </App>
            )
        When React encounters a custom HTML tag that references another component, it renders the markup for that component in the location of the tag.
            This should illustrate the parent/child relationship between the parent component and child components

Use React to Render Nested Components
    Component composition is one of React's powerful features.
        When you work with React, it is important to start thinking about your use interface in terms of components.
        You break down your UI into its basic building blocks, and those pieces become the components.
            This helps to separate the code responsible for the UI from the code responsible for handling your application logic.
            It can greatly simplify the development and maintenance of complex projects.

Compose React Components
    You can render JSX elements, stateless functional components, and ES6 class components within other components.

Render a Clas Component to the DOM
    For React components, you need to use the same syntax as if you were rendering a nested component.
        e.g.: ReactDOM.render(<ComponentToRender />, targetNode)
            You use this syntax for both ES6 class components and functional components.

Write a React Component from Scratch
    A typical React component is an ES6 "class" that extend "React.component".
        It has a render method that returns HTML (from JSX) or "null".
    e.g.:
        class ____ extends React.Component {
            constructor(____) {
                super(____);
            }
            render() {
                return (
                    ____ (HTML)
                )
            }
        }

Pass Props to a Stateless Functional Component
    In React, you can pass props, or properties, to child components.
    You use custom HTML attributes created by You and supported by React to be passed to the component.
    It is standard to call this value props and when dealing with stateless functional components, you basically consider it as an argument to a function which returns JSX.

Pass an Array as Props
    To pass an array to a JSX element, it must be treated as JavaScript and wrapped in curly braces.
        e.g.:
            <ParentComponent>
                <ChildComponent colors={["green", "blue", "red"]} />
            <ParentComponent>
    Array methods such as 'join()' can be used when accessing hte property.
        e.g.:
            const ChildComponent = (prop) => <p>{props.colors.join(", ")}</p>
            => <p>green, blue, red</p>

Use Default Props
    You can assign default props to a component as a property onm the component itself and React assigns the default prop if necessary.
        This allows you to specify what a prop value should be if no value is explicitly provided.
            e.g.: MyComponent.defaultProps = {location: 'San Francisco'}
        React assigns default props if props are undefined, but if you pass 'null' as the value for a prop, it will remain 'null'.

Override Default Props
    The way to override the default props is to explicitly set the prop values for a component.

Use PropTypes to Define the Props You Expect
    React provides usefulf type-checking features to verify that components receive props of the correct type.
        You can set 'propTypes' on your component to require the data to be of type 'array'
            This will throw a useful warning when the data is of any other type.
    It's considered a best practice to set propTypes when you know the type ofa prop ahead of time.
        You can define a propTypes property for a componentin the same way you defined defaultProps.
            Doing this will check that props of a given key are present with a given type.
        e.g.: 
            Component.propTypes = {handleClick: PropTypes.func.isRequired}
                PropTypes.func checks that handleClick is a function
                isRequired tells React that handleClick is a required property for that component.
                    You will see a awarning if that prop isn't provided. 
        Among the seven JS primitive types, function and boolean are the only two that use unusual spelling.
            func for function
            bool for boolean

Access Props Using this.props
    The ES6 class component uses a slightly different convention to access props.
    Anytime you refear to a class component within itself, you use the 'this' keyword.
        To access props within a class component, you preface the code that you use to access it with 'this'.
            e.g.: if an ES6 class component has a prop called "data", you write {this.props.data} in JSX.

Review Using Props with Stateless Functional Components
    Stateless functional components act like pure functions.
        They accept props as input and return the same view every time they are passed the same props.
    A "stateless functional component" is any function you write which accepts props and returns JSX.
        A "stateless component", on the other hand, is a class that extends React.Component, but does not use internal state.
        You may see stateful components referred to simply as components or React components.
    A common pattern is to try to minimize statefulness and to create stateless functional components wherever possibble.
        This helps contain your state manaagement to a specific area of your application.
            In turn, this improves development and maintenance of your app by making it easier to follow how changes to state affect its behavior.

Create a Stateful Component
    One of the most important topics in React is "state"
        State consists of any data your application needs to know about, that can change over time.
        You want your apps to respond to state changes and present an updated UI when necessary.
    You create state in a React component by declaring a "state" property on the component class in its "constructor".
        This initializes the component with "state" when it is created.
        The "state" property must be set to a JS "object".
            e.g.: 
            this.state = {
                ____
            }
    You have access to the "state" object throughout the life of your component.
        You can update it, render it in your UI, and pass it as props to child components.
        The "state" objec t can be as complex or as simple as you need it to be.
            Note: you must create a class component by extending 'React.Component' in order to create 'state' like this.

Render State in the User interface
    Once you define a component's initial state, you can display any part of it in the UI that is rendered.
        If a component is stateful, it will always have access to the data in 'state' in its 'render()' method.
        You can access the data with 'this.state'.
    If you want to access a state value within the 'return' of the render method, you have to enclose the value in curly braces.
    'state' is one of the most powerful features of components in React.
        It allows you to t rack important data in your app and render a UI in response to changes in this data.
            If your data changes, your UI will change.
        React uses a virtual DOM, to keep track of changes behind the scenes.
            When state data updates, it triggers a re-render of the components using that data - including child components that received the data as a prop.
            React updates the actual DOM, but only where necessary.
                This means you don;t have to worry about changing the DOM.
                You simply declare what the UI should look like.
        Note: if you make a component stateful, no other components are aware of its 'state'.
            Its 'state' is completely encapsulated, or local to that component, unless you pass state data to a child component as 'props'.
                This notion of encapsualted 'satate' is very important because it allows you to write certain logic, then have that logic contained and isolated in one place in your code.

Render State in the User Interface Another Way
    In the 'render()' mnethod, before the 'return' statement, you can write JS directly.
        e.g.: you could declare functions, access date from 'state' or 'props', perform computations on this data, and so on.
            Then you can assign any data to variables, which you have access to in the 'return' statement.
        e.g.:
            render() {
                const ____ = ____
                return (
                    <h1>____</h1>
                )
            }

Set State with this.setState
    React provides a method for updating component 'state' called 'setState'.
        You call the 'setState' method within your component class like so: this.setState(), passing in an object with key-value pairs.
    React expects you to never modify 'state' directly, instead always using this.setState() when state changes occur.
        React may batch multiple state updates in order to improve performance.
            I.e., state updates through the 'setState' method can be asynchronous.
        
Bind 'this' to a Class Method
    A class method typically needs to use the 'this' keyword so it can access properties on the class (such as 'state' and 'props') inside the scope of the method.
    There are a few ways to allow your class methods to access 'this'
        One common way is to explicitly bind 'this' in the constructor so 'this' becomes bound to the class methods when the component is initialized.

Use State to Toggle an Element
    Sometimes you might need to know the previous state when updating the sate. However, state updates may be asynchronous - this means React may batch multiple setState() clals into a single update.
        This means you can't rely on the previous value of this.state or this.props when calculating the next value.
    You should pass 'setState' a function that allows you to access state and props.
        Using a function with 'setState' guarantees you are working with the most current values of state and props.
    e.g.:
        this.____ = this.____.bind(this) -> bind 'this'
        ...
        ____() {
            this.setState(state => ({
                _________
            }))
        }

Write a Simple Counter
    Create increment, decrement, and reset method

Create a Controlled Input
    Your application may have more complex interactions between 'state' and the rendered UI.
        With React, yoiu can move this mutable state into a React component's 'state'.
        The user's input becomes part of the application 'state', so React controls the value of that input field.

Create a Controlled Form
    You must call 'event.preventDefault()' in the submit handler, to prevent the default form submit behavior which will refresh the web page.

Pass State as Props to Child Components
    A common pattern is to have a stateful component contraining the 'state' important to your app, that then renders child components.
        You want these components to have access to some pieces of that 'state', which are passed in as props.
        This pattern illustrates some important paradigms in React.
            The first is unidirectional data flow.
                State flows in one direction down the tree of your paplication's components, from the stateful parent component to child components.
                The child components only receive the state data they need.
            The second is that complex satateful apps can be broken down into just a few, or maybe a single, stateful component.
                The rest of your components simply receive state from the as props, and render a UI from that state.
                It begins to cresate a separation where state management is handled in one part of code and UI rendering in another.
                This principle of separating state logic from UI logic is one of React's key principles.
                    When it's used correctly, it makes the design of complex, stateful applications much easier to manage. 